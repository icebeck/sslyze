#summary One-sentence summary of this page.

= Introduction =

Add your content here.


=Installation=
Testing was done 70% on Windows 7 (32 and 64 bits), 29% on Ubuntu 10.04 (32 and 64 bits) and 1% on Snow Leopard 32 bits... 

Installation should be easy:
 * On Linux/Mac OS X: You need Python 2.6 or 2.7 and OpenSSL 0.9.8 or 1.0.0. [http://labs.isecpartners.com/alban/ssltool/SSLscan-v_0_2.zip Package is here].
 * On Windows: You only need Python 2.6 or 2.7, because I've created packages with the OpenSSL DLLs in them. So there are two Windows packages [http://labs.isecpartners.com/alban/ssltool/SSLscan-v_0_2-Win7-Python32.zip one for Python 32 bits] and [http://labs.isecpartners.com/alban/ssltool/SSLscan-v_0_2-Win7-Python64.zip one for Python 64 bits]. If you're on Win7 64 bits, you might still have installed Python 32 bits, so pay attention.



=Usage=

This command line will start a "regular" scan, and that's what you'll want to use most of the time: 
 $ python main.py [options] www.target1.com www.target2.com:443 etc... 

For now the tool will only print results of the scans it performed, and will not tell you if there are any security issues. So you have to know a bit about SSL in order to understand the results and know what to look for, but this manual will help you. 
Let's see what those options mean and what to look for: 


=== Regular Scan "--regular" ===
Performs a regular scan. It's a shortcut for "--sslv2 --sslv3 --tlsv1 --reneg --resum --certinfo=basic".


=== Supported Cipher Suites "--sslv2", "--sslv3", "--tlsv1"=== 
Lists the SSL 2.0 / SSL 3.0 / TLS 1.0 OpenSSL cipher suites supported by the server. 

Things to look for: 
 * Any cipher suite with SSL 2.0. SSL version 2 is completely broken. See http://www.schneier.com/paper-ssl-revised.pdf. 
 * Any cipher suite that has less than a 128 bit key length. 
 * Any anonymous cipher suite. They have 'ADH' in their name ("ADH-RC4-MD5" for example), which means Anonymous Diffie Hellman. When an anonymous cipher is chosen during the handshake, the server does not send back any certificate, but the handshake succeeds. No server authentication eliminates the security guarantees SSL/TLS is expected to provide. 


===Session Renegotiation "--reneg"===
Checks whether the server is vulnerable to insecure renegotiation. 

Session renegotiation is a mechanism within the SSL protocol that allows the client or the server to trigger the renewal of the crypto keys, during an ongoing SSL communication. 
There's a protocol flaw in that mechanism that was found in 2009. This flaw allows a network attacker to inject data at the beginning of a SSL communication. For example the attacker can inject a HTTP request as if they were the victim. Impact solely depends on what the web application running on the server does, but regardless of that, it's a breach in the security SSL is expected to provide. 

Renegotiation was initially designed for two scenarios. First, it can be used to increase the security of an ongoing SSL channel, by triggering the renewal of the crypto keys used to secure that channel. This security measure isn't necessary with modern cryptographic algorithms. Renegotiation can also be used when client authentication is enabled, so that the server can ask for a client certificate when the client tries to access protected ressources on the server.

Insecure renegotiation can be fixed using one of the two following mitigations: 
 * Prevent the server from honoring client-intiated session renegotiations.
 * Update the SSL library used by the server to a recent version. A fix making session renegotiation secure was developed at the protocol level (RFC 5746), and was subsequently implemented in all of the mostly used SSL libraries.


===Session Resumption "--resum"=== 
Tests the server for session resumption support, using both session IDs and TLS session tickets (RFC 5077). 
Session resumption is a performance optimization that allows a client/server pair to re-use previously generated crypto material, so that they don't have to compute new crypto keys every time a connection gets established. Because it greatly reduces the overhead caused by SSL/TLS, it's a crucial server configuration to make SSL/TLS affordable. 
If the domain being tested relies on a load balancer that dispatches incoming connections to multiple servers, "--resum_rate" should be used as well for a more accurate analysis.

===Session Resumption Rate "--resum_rate"=== 
Estimates the average rate of successful session resumptions by performing 100 session resumptions. 
This option is useful when analyzing large scale websites. On such websites, one single domain can be served by multiple servers, all sitting behind a load balancer that dispatches incoming connections to those servers, based on load balancing and policy rules. This causes issues for SSL session resumption because for a given client, only the server that did the initial handshake has the client's session ID and info cached. So if on its next connection, the client gets dispatched to a different server, the client's SSL session cannot be resumed because the new server doesn't know about it. 

Consequently, it's valuable to estimate the rate at which succesful session resumptions actually happen, because while all the servers may have session resumption enabled, a misconfigured load balancer can ruin SSL performance.

===Server Certificate Validation "--certinfo=basic"=== 
Verifies the server's certificate validity against Mozilla's trusted root store, and prints relevant fields of the certificate.

== Additional Options ==

=== Client Certificate Support ===
If the server requires mutual authentication, SSLyze can be configured to use a client certificate using the following commands:
  --cert=CERT           Client certificate filename.
  --certform=CERTFORM   Client certificate format. DER or PEM (default).
  --key=KEY             Client private key filename.
  --keyform=KEYFORM     Client private key format. DER or PEM (default).
  --pass=KEYPASS        Client private key passphrase.


=== Connections Timeout "--timeout=TIMEOUT"=== 
The timeout value used for every socket connection made to the target server(s) can be controled. This is useful when the target server is too slow to respond. Default value is 5s. 